<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BANCAMP // STUDIO V4 [THREE.JS_EDITION]</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rubik+Glitch&display=swap');
        
        :root { 
            --green: #33ff00; 
            --bg: #050505; 
            --font: 'Courier New', monospace; 
        }
        
        body { 
            background: var(--bg); 
            color: var(--green); 
            font-family: var(--font); 
            margin: 20px; 
            overflow-x: hidden; 
        }
        
        .grid { 
            display: grid; 
            grid-template-columns: 380px 1fr; 
            gap: 20px; 
        }
        
        .panel { 
            border: 1px solid var(--green); 
            padding: 20px; 
            background: rgba(0,0,0,0.8); 
            box-shadow: 0 0 15px rgba(51,255,0,0.1); 
        }
        
        .preview-wrap { 
            position: relative; 
            width: 640px; 
            height: 360px; 
            border: 1px solid #333; 
            background: #000; 
            overflow: hidden;
        }
        
        #renderCanvas { 
            width: 100%; 
            height: 100%; 
        }
        
        label { 
            display: block; 
            margin-top: 15px; 
            font-size: 0.8rem; 
            opacity: 0.8; 
        }
        
        input, select, button {
            width: 100%; 
            margin: 5px 0 15px; 
            padding: 10px;
            background: #111; 
            color: var(--green); 
            border: 1px solid var(--green);
            font-family: inherit; 
            cursor: pointer; 
            box-sizing: border-box;
        }
        
        button { 
            font-weight: bold; 
            font-size: 1rem; 
        }
        
        button:disabled { 
            opacity: 0.3; 
            cursor: wait; 
        }
        
        #log { 
            font-size: 0.7rem; 
            height: 220px; 
            overflow-y: auto; 
            border-top: 1px dashed var(--green); 
            padding-top: 10px; 
            color: #aaa; 
        }
        
        .progress-bar { 
            height: 6px; 
            background: #222; 
            margin: 10px 0; 
            border: 1px solid #333; 
        }
        
        #progress-fill { 
            height: 100%; 
            background: var(--green); 
            width: 0%; 
            transition: width 0.1s; 
            box-shadow: 0 0 10px var(--green); 
        }
        
        .status-msg { 
            color: var(--green); 
            font-weight: bold; 
        }
        
        .glitch-lyrics {
            font-family: 'Rubik Glitch', cursive;
            font-size: 48px;
            color: #fff;
            text-transform: uppercase;
            text-align: center;
            text-shadow: 
                0 0 10px rgba(51,255,0,0.8),
                0 0 20px rgba(51,255,0,0.5),
                2px 2px 3px rgba(255,0,255,0.4),
                -2px -2px 3px rgba(0,255,255,0.4);
        }
    </style>
</head>
<body>
    <h1>>> BANCAMP_STUDIO_V4.exe <span style="font-size: 0.5em; opacity: 0.5;">[THREE.JS_EDITION]</span></h1>

    <div class="grid">
        <div class="panel">
            <label>1. SOURCE_AUDIO (.mp3 / .wav)</label>
            <input type="file" id="audioInput" accept="audio/*">

            <label>2. LYRICS_FILE (.lrc)</label>
            <input type="file" id="lrcInput" accept=".lrc">

            <label>3. VISUAL_PROTOCOL [THREE.JS]</label>
            <select id="vizSelect">
                <option value="particles3d">PARTICLES 3D üåü</option>
                <option value="waveform3d">WAVEFORM 3D üåä</option>
                <option value="sphere">AUDIO SPHERE üîÆ</option>
                <option value="tunnel">TUNNEL VISION üï≥Ô∏è</option>
                <option value="galaxy">GALAXY SPIRAL üåå</option>
                <option value="cube">CUBE MATRIX üé≤</option>
                <option value="plasma">PLASMA FIELD ‚ö°</option>
                <option value="dna">DNA HELIX üß¨</option>
                <option value="vortex">VORTEX SPIN üåÄ</option>
                <option value="grid3d">3D GRID PULSE üìä</option>
                <option value="rings">ORBITAL RINGS üí´</option>
                <option value="nebula">NEBULA CLOUD ‚òÅÔ∏è</option>
            </select>

            <label>4. BATCH SIZE (frames per upload)</label>
            <select id="batchSize">
                <option value="30">30 (safer)</option>
                <option value="60" selected>60 (balanced)</option>
                <option value="120">120 (faster)</option>
            </select>

            <label>5. FRAME RATE</label>
            <select id="fpsSelect">
                <option value="24">24 FPS (fast render)</option>
                <option value="30" selected>30 FPS (recommended)</option>
                <option value="60">60 FPS (slow, smooth)</option>
            </select>

            <button id="renderBtn">START COMPILATION</button>
            <div class="progress-bar"><div id="progress-fill"></div></div>
            <div id="log">> STANDBY // THREEJS READY</div>
        </div>
        
        <div class="panel">
            <div class="preview-wrap">
                <canvas id="renderCanvas" width="1280" height="720"></canvas>
            </div>
            <p>// OUTPUT: 720p_HD // THREEJS // NATIVE_FFMPEG</p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
        const logEl = document.getElementById('log');
        const canvas = document.getElementById('renderCanvas');
        let lrcEntries = [];
        let scene, camera, renderer;
        let currentVisualizer = null;

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, 1280/720, 0.1, 1000);
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: false
            });
            renderer.setSize(1280, 720);
            renderer.setClearColor(0x000000);
            
            log("THREE.JS INITIALIZED", true);
        }

        function log(msg, isStatus = false) {
            const div = document.createElement('div');
            if (isStatus) div.className = 'status-msg';
            div.innerText = `> ${msg}`;
            logEl.appendChild(div);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function parseLRC(text) {
            const lines = text.split('\n');
            const entries = [];
            for (const line of lines) {
                const match = line.match(/\[(\d{2}):(\d{2})\.(\d{2,3})\](.*)/);
                if (match) {
                    const [, min, sec, ms, txt] = match;
                    const time = parseInt(min) * 60 + parseInt(sec) + parseInt(ms) / (ms.length === 2 ? 100 : 1000);
                    entries.push({ time, text: txt.trim() });
                }
            }
            return entries;
        }

        async function getAudioFrequencyMap(file, fps) {
            const arrayBuffer = await file.arrayBuffer();
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            const duration = audioBuffer.duration;
            const frameCount = Math.ceil(duration * fps);
            const analyzer = audioContext.createAnalyser();
            analyzer.fftSize = 2048;
            
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(analyzer);
            
            const bufferLength = analyzer.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            const map = [];
            const samplesPerFrame = audioBuffer.sampleRate / fps;
            const channelData = audioBuffer.getChannelData(0);
            
            for (let i = 0; i < frameCount; i++) {
                const startSample = Math.floor(i * samplesPerFrame);
                const endSample = Math.min(startSample + samplesPerFrame, channelData.length);
                
                const freqs = new Array(32).fill(0);
                for (let j = startSample; j < endSample; j++) {
                    const sample = Math.abs(channelData[j]);
                    const freqIndex = Math.min(31, Math.floor((j - startSample) / samplesPerFrame * 32));
                    freqs[freqIndex] = Math.max(freqs[freqIndex], sample);
                }
                
                map.push(freqs);
            }
            
            return { map, duration };
        }

        // ========== THREE.JS VISUALIZERS ==========
        
        class Particles3DVisualizer {
            constructor() {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                for (let i = 0; i < 5000; i++) {
                    positions.push(
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50
                    );
                    colors.push(Math.random(), Math.random(), Math.random());
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.15,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.particles = new THREE.Points(geometry, material);
                scene.add(this.particles);
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                this.particles.rotation.x += 0.001 + avg * 0.05;
                this.particles.rotation.y += 0.002 + avg * 0.03;
                
                const positions = this.particles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const freqIndex = Math.floor((i / 3) % audioData.length);
                    const scale = 1 + audioData[freqIndex] * 2;
                    positions[i] *= scale * 0.99;
                    positions[i + 1] *= scale * 0.99;
                    positions[i + 2] *= scale * 0.99;
                }
                this.particles.geometry.attributes.position.needsUpdate = true;
            }
            
            destroy() {
                scene.remove(this.particles);
            }
        }
        
        class Waveform3DVisualizer {
            constructor() {
                this.bars = [];
                const barCount = 32;
                const spacing = 0.5;
                
                for (let i = 0; i < barCount; i++) {
                    const geometry = new THREE.BoxGeometry(0.3, 1, 0.3);
                    const hue = i / barCount;
                    const material = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(hue, 1, 0.5),
                        transparent: true,
                        opacity: 0.8
                    });
                    const bar = new THREE.Mesh(geometry, material);
                    bar.position.x = (i - barCount / 2) * spacing;
                    scene.add(bar);
                    this.bars.push(bar);
                }
            }
            
            update(audioData, frame) {
                this.bars.forEach((bar, i) => {
                    const targetHeight = 1 + audioData[i] * 10;
                    bar.scale.y = bar.scale.y * 0.8 + targetHeight * 0.2;
                    bar.rotation.y += 0.01;
                });
                camera.position.z = 15 + Math.sin(frame * 0.01) * 2;
            }
            
            destroy() {
                this.bars.forEach(bar => scene.remove(bar));
            }
        }
        
        class AudioSphereVisualizer {
            constructor() {
                const geometry = new THREE.IcosahedronGeometry(2, 4);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00ff88,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                this.sphere = new THREE.Mesh(geometry, material);
                scene.add(this.sphere);
                
                // Add glow
                const glowGeometry = new THREE.IcosahedronGeometry(2.2, 3);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.BackSide
                });
                this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
                scene.add(this.glow);
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                const scale = 1 + avg * 3;
                this.sphere.scale.set(scale, scale, scale);
                this.glow.scale.set(scale * 1.1, scale * 1.1, scale * 1.1);
                
                this.sphere.rotation.x += 0.005;
                this.sphere.rotation.y += 0.01;
                
                const hue = (frame * 0.001) % 1;
                this.sphere.material.color.setHSL(hue, 1, 0.5);
            }
            
            destroy() {
                scene.remove(this.sphere);
                scene.remove(this.glow);
            }
        }
        
        class TunnelVisualizer {
            constructor() {
                this.rings = [];
                for (let i = 0; i < 20; i++) {
                    const geometry = new THREE.TorusGeometry(3, 0.3, 16, 32);
                    const hue = i / 20;
                    const material = new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(hue, 1, 0.5),
                        transparent: true,
                        opacity: 0.6
                    });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.position.z = -i * 2;
                    scene.add(ring);
                    this.rings.push(ring);
                }
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                this.rings.forEach((ring, i) => {
                    ring.position.z += 0.1 + avg * 0.5;
                    if (ring.position.z > 5) {
                        ring.position.z = -38;
                    }
                    ring.rotation.z += 0.01 + audioData[i % audioData.length] * 0.1;
                    const scale = 1 + audioData[i % audioData.length] * 2;
                    ring.scale.set(scale, scale, 1);
                });
            }
            
            destroy() {
                this.rings.forEach(ring => scene.remove(ring));
            }
        }
        
        class GalaxySpiralVisualizer {
            constructor() {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                for (let i = 0; i < 10000; i++) {
                    const angle = i * 0.1;
                    const radius = i * 0.003;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    const z = (Math.random() - 0.5) * 2;
                    
                    positions.push(x, y, z);
                    
                    const hue = (i / 10000) * 0.3 + 0.5;
                    const color = new THREE.Color().setHSL(hue, 1, 0.7);
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.1,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                this.galaxy = new THREE.Points(geometry, material);
                scene.add(this.galaxy);
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                this.galaxy.rotation.z += 0.001 + avg * 0.02;
                camera.position.z = 20 + Math.sin(frame * 0.005) * 5;
            }
            
            destroy() {
                scene.remove(this.galaxy);
            }
        }
        
        class CubeMatrixVisualizer {
            constructor() {
                this.cubes = [];
                const gridSize = 8;
                const spacing = 2;
                
                for (let x = 0; x < gridSize; x++) {
                    for (let y = 0; y < gridSize; y++) {
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshBasicMaterial({
                            color: 0x00ffaa,
                            wireframe: true,
                            transparent: true,
                            opacity: 0.7
                        });
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.x = (x - gridSize / 2) * spacing;
                        cube.position.y = (y - gridSize / 2) * spacing;
                        scene.add(cube);
                        this.cubes.push({ mesh: cube, baseY: cube.position.y });
                    }
                }
            }
            
            update(audioData, frame) {
                this.cubes.forEach((cube, i) => {
                    const freqIndex = i % audioData.length;
                    const scale = 1 + audioData[freqIndex] * 3;
                    cube.mesh.scale.set(scale, scale, scale);
                    cube.mesh.rotation.x += 0.01;
                    cube.mesh.rotation.y += 0.01;
                    
                    const hue = (i / this.cubes.length + frame * 0.001) % 1;
                    cube.mesh.material.color.setHSL(hue, 1, 0.5);
                });
                camera.rotation.y = Math.sin(frame * 0.003) * 0.3;
            }
            
            destroy() {
                this.cubes.forEach(cube => scene.remove(cube.mesh));
            }
        }
        
        class PlasmaFieldVisualizer {
            constructor() {
                this.particles = [];
                const particleCount = 3000;
                
                for (let i = 0; i < particleCount; i++) {
                    const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xff00ff,
                        transparent: true,
                        opacity: 0.6
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = Math.random() * 10;
                    particle.position.x = Math.cos(angle) * radius;
                    particle.position.y = Math.sin(angle) * radius;
                    particle.position.z = (Math.random() - 0.5) * 10;
                    
                    scene.add(particle);
                    this.particles.push({ mesh: particle, angle, radius, speed: Math.random() * 0.02 + 0.01 });
                }
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                this.particles.forEach((particle, i) => {
                    particle.angle += particle.speed + avg * 0.05;
                    const newRadius = particle.radius + Math.sin(frame * 0.01 + i) * 0.5;
                    particle.mesh.position.x = Math.cos(particle.angle) * newRadius;
                    particle.mesh.position.y = Math.sin(particle.angle) * newRadius;
                    
                    const hue = (particle.angle + frame * 0.001) % 1;
                    particle.mesh.material.color.setHSL(hue, 1, 0.5);
                });
            }
            
            destroy() {
                this.particles.forEach(p => scene.remove(p.mesh));
            }
        }
        
        class DNAHelixVisualizer {
            constructor() {
                this.spheres = [];
                const count = 50;
                
                for (let i = 0; i < count; i++) {
                    const geometry = new THREE.SphereGeometry(0.2, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                    const sphere1 = new THREE.Mesh(geometry, material);
                    const sphere2 = new THREE.Mesh(geometry, material.clone());
                    sphere2.material.color.set(0xff00ff);
                    
                    scene.add(sphere1);
                    scene.add(sphere2);
                    this.spheres.push({ s1: sphere1, s2: sphere2, index: i });
                }
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                this.spheres.forEach(({ s1, s2, index }) => {
                    const t = frame * 0.02 + index * 0.5;
                    const radius = 2 + avg * 3;
                    
                    s1.position.x = Math.cos(t) * radius;
                    s1.position.y = Math.sin(t) * radius;
                    s1.position.z = index * 0.3 - 7.5;
                    
                    s2.position.x = Math.cos(t + Math.PI) * radius;
                    s2.position.y = Math.sin(t + Math.PI) * radius;
                    s2.position.z = index * 0.3 - 7.5;
                });
            }
            
            destroy() {
                this.spheres.forEach(({ s1, s2 }) => {
                    scene.remove(s1);
                    scene.remove(s2);
                });
            }
        }
        
        class VortexSpinVisualizer {
            constructor() {
                this.lines = [];
                for (let i = 0; i < 30; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    for (let j = 0; j < 100; j++) {
                        const angle = j * 0.1 + i * 0.2;
                        const radius = j * 0.05;
                        points.push(new THREE.Vector3(
                            Math.cos(angle) * radius,
                            Math.sin(angle) * radius,
                            j * 0.1 - 5
                        ));
                    }
                    geometry.setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: new THREE.Color().setHSL(i / 30, 1, 0.5),
                        transparent: true,
                        opacity: 0.6
                    });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                    this.lines.push(line);
                }
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                this.lines.forEach((line, i) => {
                    line.rotation.z += 0.01 + avg * 0.1;
                    const hue = (i / this.lines.length + frame * 0.001) % 1;
                    line.material.color.setHSL(hue, 1, 0.5);
                });
            }
            
            destroy() {
                this.lines.forEach(line => scene.remove(line));
            }
        }
        
        class Grid3DPulseVisualizer {
            constructor() {
                this.grid = [];
                const size = 20;
                const divisions = 40;
                const step = size / divisions;
                
                for (let i = 0; i <= divisions; i++) {
                    for (let j = 0; j <= divisions; j++) {
                        const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.x = i * step - size / 2;
                        sphere.position.y = 0;
                        sphere.position.z = j * step - size / 2;
                        scene.add(sphere);
                        this.grid.push({ mesh: sphere, baseY: 0, i, j });
                    }
                }
                camera.position.y = 8;
                camera.rotation.x = -0.5;
            }
            
            update(audioData, frame) {
                this.grid.forEach(({ mesh, i, j }) => {
                    const distance = Math.sqrt(Math.pow(i - 20, 2) + Math.pow(j - 20, 2));
                    const wave = Math.sin(distance * 0.3 - frame * 0.1);
                    const freqIndex = Math.floor(distance) % audioData.length;
                    mesh.position.y = wave * 2 + audioData[freqIndex] * 5;
                    
                    const hue = (distance / 40 + frame * 0.001) % 1;
                    mesh.material.color.setHSL(hue, 1, 0.5);
                });
            }
            
            destroy() {
                this.grid.forEach(({ mesh }) => scene.remove(mesh));
                camera.position.y = 0;
                camera.rotation.x = 0;
            }
        }
        
        class OrbitalRingsVisualizer {
            constructor() {
                this.rings = [];
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.TorusGeometry(2 + i, 0.1, 16, 100);
                    const material = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(i / 5, 1, 0.5),
                        transparent: true,
                        opacity: 0.7
                    });
                    const ring = new THREE.Mesh(geometry, material);
                    ring.rotation.x = Math.random() * Math.PI;
                    ring.rotation.y = Math.random() * Math.PI;
                    scene.add(ring);
                    this.rings.push({ mesh: ring, speedX: Math.random() * 0.02, speedY: Math.random() * 0.02 });
                }
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                this.rings.forEach(({ mesh, speedX, speedY }, i) => {
                    mesh.rotation.x += speedX + avg * 0.05;
                    mesh.rotation.y += speedY + avg * 0.05;
                    const scale = 1 + audioData[i * 6] * 2;
                    mesh.scale.set(scale, scale, scale);
                });
            }
            
            destroy() {
                this.rings.forEach(({ mesh }) => scene.remove(mesh));
            }
        }
        
        class NebulaCloudVisualizer {
            constructor() {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                const sizes = [];
                
                for (let i = 0; i < 8000; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = Math.random() * 10 + 5;
                    
                    positions.push(
                        radius * Math.sin(phi) * Math.cos(theta),
                        radius * Math.sin(phi) * Math.sin(theta),
                        radius * Math.cos(phi)
                    );
                    
                    const hue = Math.random() * 0.3 + 0.5;
                    const color = new THREE.Color().setHSL(hue, 1, 0.6);
                    colors.push(color.r, color.g, color.b);
                    sizes.push(Math.random() * 0.5 + 0.1);
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 0.3,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.nebula = new THREE.Points(geometry, material);
                scene.add(this.nebula);
            }
            
            update(audioData, frame) {
                const avg = audioData.reduce((a, b) => a + b) / audioData.length;
                this.nebula.rotation.x += 0.0005 + avg * 0.01;
                this.nebula.rotation.y += 0.001 + avg * 0.02;
                camera.position.z = 15 + Math.sin(frame * 0.01) * 3;
            }
            
            destroy() {
                scene.remove(this.nebula);
            }
        }

        const visualizers = {
            particles3d: Particles3DVisualizer,
            waveform3d: Waveform3DVisualizer,
            sphere: AudioSphereVisualizer,
            tunnel: TunnelVisualizer,
            galaxy: GalaxySpiralVisualizer,
            cube: CubeMatrixVisualizer,
            plasma: PlasmaFieldVisualizer,
            dna: DNAHelixVisualizer,
            vortex: VortexSpinVisualizer,
            grid3d: Grid3DPulseVisualizer,
            rings: OrbitalRingsVisualizer,
            nebula: NebulaCloudVisualizer
        };

        // Render frame to canvas with Three.js + lyrics overlay
        function renderFrame(audioData, currentTime, frame) {
            // Update visualizer
            if (currentVisualizer) {
                currentVisualizer.update(audioData, frame);
            }
            
            // Render Three.js scene
            renderer.render(scene, camera);
            
            // Get canvas context for lyrics overlay
            const ctx = canvas.getContext('2d');
            
            // Draw lyrics on top
            const activeLrc = lrcEntries.filter(e => e.time <= currentTime).pop();
            if (activeLrc) {
                ctx.save();
                ctx.font = "bold 48px 'Rubik Glitch', 'Courier New', monospace";
                ctx.fillStyle = "#ffffff";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                // Glitch shadow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#00ff00";
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Stroke for better visibility
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#000000";
                ctx.strokeText(activeLrc.text.toUpperCase(), 640, 650);
                
                // Fill text
                ctx.fillText(activeLrc.text.toUpperCase(), 640, 650);
                
                ctx.restore();
            }
        }

        // Main render button handler
        document.getElementById('renderBtn').onclick = async () => {
            const FPS = parseInt(document.getElementById('fpsSelect').value);
            const audioFile = document.getElementById('audioInput').files[0];
            const lrcFile = document.getElementById('lrcInput').files[0];
            
            if (!audioFile) {
                alert("SELECT SOURCE AUDIO");
                return;
            }

            const btn = document.getElementById('renderBtn');
            btn.disabled = true;
            btn.innerText = "RENDERING...";
            document.getElementById('progress-fill').style.width = '0%';
            
            // Initialize Three.js if not already done
            if (!renderer) {
                initThreeJS();
            }

            try {
                // 1. Start session
                log("STARTING SESSION...");
                const session = await fetch('/api/start', { method: 'POST' }).then(r => r.json());
                const sid = session.session_id;
                log(`SESSION: ${sid}`, true);

                // 2. Upload audio
                log("UPLOADING AUDIO...");
                const audioForm = new FormData();
                audioForm.append('audio', audioFile);
                await fetch(`/api/audio/${sid}`, { method: 'POST', body: audioForm });
                log("AUDIO UPLOADED.");

                // 3. Decode audio for visualization
                log("DECODING AUDIO...");
                const { map } = await getAudioFrequencyMap(audioFile, FPS);
                if (lrcFile) {
                    const lrcText = await lrcFile.text();
                    lrcEntries = parseLRC(lrcText);
                    log(`LOADED ${lrcEntries.length} LYRIC LINES`);
                }

                // 4. Initialize selected visualizer
                const vizType = document.getElementById('vizSelect').value;
                log(`INITIALIZING ${vizType.toUpperCase()} VISUALIZER...`, true);
                
                // Clean up old visualizer
                if (currentVisualizer) {
                    currentVisualizer.destroy();
                }
                
                // Create new visualizer
                const VisualizerClass = visualizers[vizType] || Particles3DVisualizer;
                currentVisualizer = new VisualizerClass();
                
                const batchSize = parseInt(document.getElementById('batchSize').value);
                const totalFrames = map.length;
                log(`RENDERING ${totalFrames} FRAMES...`, true);

                // 5. Render + upload in batches
                let batch = [];

                for (let i = 0; i < totalFrames; i++) {
                    const currentTime = i / FPS;
                    const audioData = map[i];

                    // Render frame with Three.js + lyrics
                    renderFrame(audioData, currentTime, i);

                    // Convert canvas to blob
                    const frameBlob = await new Promise(r => canvas.toBlob(r, 'image/webp', 0.75));
                    batch.push({ index: i, blob: frameBlob });

                    // Upload batch with concurrency control
                    if (batch.length >= batchSize || i === totalFrames - 1) {
                        const chunks = [];
                        for (let c = 0; c < batch.length; c += 5) {
                            chunks.push(batch.slice(c, c + 5));
                        }
                        for (const chunk of chunks) {
                            await Promise.all(chunk.map(({ index, blob }) => {
                                const form = new FormData();
                                form.append('frame_index', index);
                                form.append('frame', blob, `f${index}.webp`);
                                return fetch(`/api/frame/${sid}`, { method: 'POST', body: form });
                            }));
                        }
                        batch = [];
                    }

                    if (i % 30 === 0 || i === totalFrames - 1) {
                        const pct = ((i / totalFrames) * 100).toFixed(1);
                        document.getElementById('progress-fill').style.width = `${pct}%`;
                        log(`FRAMES: ${i}/${totalFrames} (${pct}%)`);
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                document.getElementById('progress-fill').style.width = '100%';

                // 6. Compile
                log("COMPILING VIDEO (server-side ffmpeg)...", true);
                const compileForm = new FormData();
                compileForm.append('fps', FPS);
                const result = await fetch(`/api/compile/${sid}`, {
                    method: 'POST',
                    body: compileForm
                }).then(r => r.json());

                if (result.error) {
                    log("COMPILE ERROR: " + result.error, true);
                    btn.disabled = false;
                    btn.innerText = "START COMPILATION";
                    return;
                }

                log("COMPILATION COMPLETE!", true);
                log(`DOWNLOAD: <a href="${result.download}" style="color: var(--green);">CLICK HERE</a>`, true);

                // Auto download
                const a = document.createElement('a');
                a.href = result.download;
                a.download = `BANCAMP_${sid}.mp4`;
                a.click();

                // Cleanup
                setTimeout(async () => {
                    await fetch(`/api/cleanup/${sid}`, { method: 'DELETE' });
                    log("SESSION CLEANED UP");
                }, 5000);

            } catch (error) {
                log(`ERROR: ${error.message}`, true);
                console.error(error);
            } finally {
                btn.disabled = false;
                btn.innerText = "START COMPILATION";
            }
        };

        // Initialize on load
        window.addEventListener('load', () => {
            initThreeJS();
        });
    </script>
</body>
</html>