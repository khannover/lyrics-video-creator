<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>BANCAMP // STUDIO V4</title>
    <style>
        :root { --green: #33ff00; --bg: #050505; --font: 'Courier New', monospace; }
        body { background: var(--bg); color: var(--green); font-family: var(--font); margin: 20px; overflow-x: hidden; }
        .grid { display: grid; grid-template-columns: 380px 1fr; gap: 20px; }
        .panel { border: 1px solid var(--green); padding: 20px; background: rgba(0,0,0,0.8); box-shadow: 0 0 15px rgba(51,255,0,0.1); }
        .preview-wrap { position: relative; width: 640px; height: 360px; border: 1px solid #333; background: #000; }
        canvas { width: 100%; height: 100%; object-fit: contain; }
        label { display: block; margin-top: 15px; font-size: 0.8rem; opacity: 0.8; }
        input, select, button {
            width: 100%; margin: 5px 0 15px; padding: 10px;
            background: #111; color: var(--green); border: 1px solid var(--green);
            font-family: inherit; cursor: pointer; box-sizing: border-box;
        }
        button { font-weight: bold; font-size: 1rem; }
        button:disabled { opacity: 0.3; cursor: wait; }
        #log { font-size: 0.7rem; height: 220px; overflow-y: auto; border-top: 1px dashed var(--green); padding-top: 10px; color: #aaa; }
        .progress-bar { height: 6px; background: #222; margin: 10px 0; border: 1px solid #333; }
        #progress-fill { height: 100%; background: var(--green); width: 0%; transition: width 0.1s; box-shadow: 0 0 10px var(--green); }
        .status-msg { color: var(--green); font-weight: bold; }
    </style>
</head>
<body>
    <h1>>> BANCAMP_STUDIO_V4.exe <span style="font-size: 0.5em; opacity: 0.5;">[NATIVE_BACKEND]</span></h1>

    <div class="grid">
        <div class="panel">
            <label>1. SOURCE_AUDIO (.mp3 / .wav)</label>
            <input type="file" id="audioInput" accept="audio/*">

            <label>2. LYRICS_FILE (.lrc)</label>
            <input type="file" id="lrcInput" accept=".lrc">

            <label>3. VISUAL_PROTOCOL</label>
            <select id="vizSelect">
                <option value="bars">BARS</option>
                <option value="barsXXX">BARS2</option>
                <option value="ring">RING</option>
                <option value="ringXXX">RING2</option>
                <option value="wave">WAVE</option>
                <option value="waveXXX">WAVE2</option>
                <option value="rain">RAIN</option>
                <option value="rainXXX">RAIN2</option>
                <option value="aurora">AURORA</option>
                <option value="auroraXXX">AURORA2</option>
                <option value="vortex">VORTEX</option>
                <option value="vortexXXX">VORTEX2</option>
                <option value="bloom">BLOOM</option>
                <option value="bloomXXX">BLOOM2</option>
                <option value="pulsegrid">PULSE GRID</option>
                <option value="pulsegridXXX">PULSE GRID2</option>
                <option value="smoke">SMOKE GRENADE</option>
                <option value="smokeXXX">SMOKE GRENADE2</option>
                <option value="spiral3d">SPIRAL 3D</option>
                <option value="spiral3dXXX">SPIRAL 3D2</option>
                <option value="orbital">ORBITAL</option>
                <option value="orbitalXXX">ORBITAL2</option>
            </select>

            <label>4. BATCH SIZE (frames per upload)</label>
            <select id="batchSize">
                <option value="30">30 (safer)</option>
                <option value="60" selected>60 (balanced)</option>
                <option value="120">120 (faster)</option>
            </select>

            <label>5. FRAME RATE</label>
            <select id="fpsSelect">
                <option value="24">24 FPS (fast render)</option>
                <option value="30" selected>30 FPS (recommended)</option>
                <option value="60">60 FPS (slow, smooth)</option>
            </select>

            <button id="renderBtn">START COMPILATION</button>
            <div class="progress-bar"><div id="progress-fill"></div></div>
            <div id="log">> STANDBY</div>
        </div>
        <div class="panel">
            <div class="preview-wrap">
                <canvas id="renderCanvas" width="1280" height="720"></canvas>
            </div>
            <p>// OUTPUT: 720p_HD // 60FPS // NATIVE_FFMPEG</p>
        </div>
    </div>

    <script>
        const logEl = document.getElementById('log');
        const canvas = document.getElementById('renderCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let palette = ['#00ff41', '#00b3ff', '#ff00c1', '#f3ff6e'];
        let lrcEntries = [];
        // Removed global FPS constant to avoid shadowing bugs


        function log(msg, isStatus = false) {
            const div = document.createElement('div');
            if (isStatus) div.className = 'status-msg';
            div.innerText = `> ${msg}`;
            logEl.appendChild(div);
            logEl.scrollTop = logEl.scrollHeight;
        }

        document.getElementById('renderBtn').onclick = async () => {
            const FPS = parseInt(document.getElementById('fpsSelect').value);
            const audioFile = document.getElementById('audioInput').files[0];
            const lrcFile = document.getElementById('lrcInput').files[0];
            if (!audioFile) return alert("SELECT SOURCE AUDIO");

            const btn = document.getElementById('renderBtn');
            btn.disabled = true;
            btn.innerText = "RENDERING...";
            document.getElementById('progress-fill').style.width = '0%';

            try {
                // 1. Start session
                log("STARTING SESSION...");
                const session = await fetch('/api/start', { method: 'POST' }).then(r => r.json());
                const sid = session.session_id;
                log(`SESSION: ${sid}`, true);

                // 2. Upload audio
                log("UPLOADING AUDIO...");
                const audioForm = new FormData();
                audioForm.append('audio', audioFile);
                await fetch(`/api/audio/${sid}`, { method: 'POST', body: audioForm });
                log("AUDIO UPLOADED.");

                // 3. Decode audio for visualization
                log("DECODING AUDIO...");
                const { map } = await getAudioFrequencyMap(audioFile, FPS);
                if (lrcFile) lrcEntries = parseLRC(await lrcFile.text());

                const vizType = document.getElementById('vizSelect').value;
                const batchSize = parseInt(document.getElementById('batchSize').value);
                const totalFrames = map.length;
                log(`RENDERING ${totalFrames} FRAMES [${vizType.toUpperCase()}]...`, true);

                // 4. Render + upload in batches
                let batch = [];

                for (let i = 0; i < totalFrames; i++) {
                    const currentTime = i / FPS;
                    const data = map[i];

                    // Render frame
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    if (visualizers[vizType]) visualizers[vizType](ctx, canvas.width, canvas.height, data, i);
                    else visualizers.bars(ctx, canvas.width, canvas.height, data, i);

                        // Lyrics overlay
                        const activeLrc = lrcEntries.filter(e => e.time <= currentTime).pop();
                        if (activeLrc) {
                            ctx.save();
                            // Reset transform to ensure lyrics are drawn in the correct screen space
                            // independent of any leftover transforms from visualizers (just in case)
                            ctx.setTransform(1, 0, 0, 1, 0, 0); 
                            
                            ctx.font = "bold 48px 'Courier New', monospace";
                            ctx.fillStyle = "#ffffff";
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            
                            // Text Stroke/Shadow for better visibility
                            ctx.shadowBlur = 4;
                            ctx.shadowColor = "#000000";
                            ctx.lineWidth = 3;
                            ctx.strokeStyle = "#000000";
                            ctx.strokeText(activeLrc.text.toUpperCase(), canvas.width / 2, canvas.height - 80);
                            
                            ctx.fillText(activeLrc.text.toUpperCase(), canvas.width / 2, canvas.height - 80);
                            
                            ctx.restore();
                        }


                    const frameBlob = await new Promise(r => canvas.toBlob(r, 'image/webp', 0.75));
                    batch.push({ index: i, blob: frameBlob });

                    // Upload batch with concurrency control
                    if (batch.length >= batchSize || i === totalFrames - 1) {
                        // Upload 5 frames simultaneously instead of waiting for each
                        const chunks = [];
                        for (let c = 0; c < batch.length; c += 5) {
                            chunks.push(batch.slice(c, c + 5));
                        }
                        for (const chunk of chunks) {
                            await Promise.all(chunk.map(({ index, blob }) => {
                                const form = new FormData();
                                form.append('frame_index', index);
                                form.append('frame', blob, `f${index}.webp`);
                                return fetch(`/api/frame/${sid}`, { method: 'POST', body: form });
                            }));
                        }
                        batch = [];
                    }

                    if (i % 30 === 0 || i === totalFrames - 1) {
                        const pct = ((i / totalFrames) * 100).toFixed(1);
                        document.getElementById('progress-fill').style.width = `${pct}%`;
                        log(`FRAMES: ${i}/${totalFrames} (${pct}%)`);
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                document.getElementById('progress-fill').style.width = '100%';

                // 5. Compile
                log("COMPILING VIDEO (server-side ffmpeg)...", true);
                const compileForm = new FormData();
                compileForm.append('fps', FPS);
                const result = await fetch(`/api/compile/${sid}`, {
                    method: 'POST', body: compileForm
                }).then(r => r.json());

                if (result.error) {
                    log("COMPILE ERROR: " + result.error, true);
                    btn.disabled = false;
                    btn.innerText = "START COMPILATION";
                    return;
                }

                // 6. Download
                log("DOWNLOADING VIDEO...", true);
                const a = document.createElement('a');
                a.href = result.download;
                a.download = `BANCAMP_${vizType}_${sid}.mp4`;
                a.click();

                // 7. Cleanup - Wait a bit to ensure download starts/finishes
                // Better yet, don't cleanup immediately so user can retry if needed.
                // Or use a timeout.
                log("CLEANUP IN 10 SECONDS...", true);
                setTimeout(async () => {
                    await fetch(`/api/cleanup/${sid}`, { method: 'DELETE' });
                    log("CLEANUP COMPLETE.", true);
                }, 10000);


            } catch (e) {
                log("ERROR: " + e.message, true);
                console.error(e);
            }

            btn.disabled = false;
            btn.innerText = "START COMPILATION";
        };

        // --- HELPERS ---
        function parseLRC(text) {
            const entries = [];
            const lines = text.split('\n');
            const timeRegex = /\[(\d{1,2}):(\d{2})(?:\.(\d{2,3}))?\]/g;
            for (const line of lines) {
                let match;
                const txt = line.replace(timeRegex, '').trim();
                timeRegex.lastIndex = 0;
                while ((match = timeRegex.exec(line)) !== null) {
                    const min = parseInt(match[1]);
                    const sec = parseInt(match[2]);
                    const ms = match[3] ? parseInt(match[3].padEnd(3, '0')) : 0;
                    entries.push({ time: min * 60 + sec + ms / 1000, text: txt });
                }
            }
            return entries.sort((a, b) => a.time - b.time);
        }

        async function getAudioFrequencyMap(file, fps) {
            log(`DECODING AUDIO FOR ${fps} FPS...`);
            const buffer = await file.arrayBuffer();
            const audioCtx = new AudioContext();
            const audioBuffer = await audioCtx.decodeAudioData(buffer);
            
            // Calculate how many samples correspond to one video frame
            const samplesPerFrame = Math.floor(audioBuffer.sampleRate / fps);
            const frequencyMap = [];
            const rawData = audioBuffer.getChannelData(0);

            for (let i = 0; i < audioBuffer.length; i += samplesPerFrame) {
                const end = Math.min(i + samplesPerFrame, audioBuffer.length);
                const win = rawData.slice(i, end);
                
                // Calculate RMS (Root Mean Square) for volume/energy
                let sum = 0;
                for (let j = 0; j < win.length; j++) sum += win[j] * win[j];
                const rms = Math.sqrt(sum / win.length) || 0;
                
                // Amplify energy for better visuals
                const energy = Math.min(1.0, rms * 4.0);
                
                // Create a synthetic frequency spectrum based on energy
                // Real FFT on raw audio without playing it is complex in browser
                // so we approximate a "bass-heavy" spectrum scaled by volume
                const fakeSpectrum = new Uint8Array(128);
                for (let k = 0; k < 128; k++) {
                    // Falls off with frequency (like pink noise)
                    const val = energy * 255 * (1 - (k / 140));
                    fakeSpectrum[k] = Math.min(255, Math.max(0, val));
                }
                frequencyMap.push(fakeSpectrum);
            }
            
            log(`AUDIO DECODED: ${frequencyMap.length} frames @ ${fps}fps`, true);
            return { map: frequencyMap, duration: audioBuffer.duration };
        }

        // --- GRAPHICS HELPERS ---
        function gradient(ctx, w, h, horizontal = false) {
            const grad = horizontal 
                ? ctx.createLinearGradient(0, h/2, w, h/2)
                : ctx.createLinearGradient(w/2, h, w/2, 0);
            grad.addColorStop(0, palette[0]);
            grad.addColorStop(0.33, palette[1]);
            grad.addColorStop(0.66, palette[2]);
            grad.addColorStop(1, palette[3]);
            return grad;
        }

        function paletteColor(idx, alpha = 1) {
            // Convert hex to rgba
            const hex = palette[idx % palette.length];
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function drawRippleCircle(ctx, x, y, r, energy, color, bumps = 0) {
            ctx.beginPath();
            ctx.fillStyle = color;
            if (bumps > 0) {
                // Draw bumpy circle roughly like a flower/gear
                for (let i = 0; i < Math.PI * 2; i += 0.1) {
                    const radius = r + Math.sin(i * bumps) * (r * 0.2 * energy);
                    const px = x + Math.cos(i) * radius;
                    const py = y + Math.sin(i) * radius;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
            } else {
                ctx.arc(x, y, r, 0, Math.PI * 2);
            }
            ctx.fill();
        }

        // --- ALL 11 VISUALIZERS ---
        const visualizers = {
            bars: (ctx, w, h, data, frame) => {
                const barCount = Math.min(data.length, 128);
                const barWidth = w / barCount;
                ctx.fillStyle = gradient(ctx, w, h);
                for(let i=0; i<barCount; i++) {
                    const amp = data[i] / 255;
                    const barHeight = amp * h * 0.7;
                    const x = i * barWidth;
                    ctx.fillRect(x, h - barHeight, barWidth - 2, barHeight);
                    ctx.fillRect(x, 0, barWidth - 2, barHeight * 0.5);
                }
            },
            ring: (ctx, w, h, data, frame) => {
                const cx = w/2, cy = h/2;
                const segments = Math.min(data.length, 128);
                const radius = Math.min(w, h) * 0.25;
                for(let i=0; i<segments; i++) {
                    const angle = (i/segments) * Math.PI * 2 - Math.PI/2;
                    const amp = data[i] / 255;
                    const len = amp * radius;
                    const x1 = cx + Math.cos(angle) * radius;
                    const y1 = cy + Math.sin(angle) * radius;
                    const x2 = cx + Math.cos(angle) * (radius + len);
                    const y2 = cy + Math.sin(angle) * (radius + len);
                    ctx.strokeStyle = paletteColor(i, 0.8);
                    ctx.lineWidth = Math.max(2, w/segments);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            },
            wave: (ctx, w, h, data, frame) => {
                const cy = h/2;
                const step = w / data.length;
                ctx.strokeStyle = gradient(ctx, w, h, true);
                ctx.lineWidth = 3;
                ctx.beginPath();
                for(let i=0; i<data.length; i++) {
                    const amp = (data[i] / 255) * h * 0.4;
                    const x = i * step;
                    const y = cy + Math.sin(i * 0.2 + frame * 0.05) * amp;
                    if(i===0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            },
            rain: (ctx, w, h, data, frame) => {
                const drops = 80;
                for(let i=0; i<drops; i++) {
                    const idx = Math.floor((i/drops) * data.length);
                    const energy = data[idx] / 255;
                    const x = (i/drops) * w;
                    const len = energy * h * 0.6;
                    const y = ((frame * 3 + i * 73) % h) - len;
                    ctx.strokeStyle = paletteColor(i, 0.6 + energy * 0.4);
                    ctx.lineWidth = 2 + energy * 4;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + len);
                    ctx.stroke();
                }
            },
            aurora: (ctx, w, h, data, frame) => {
                const waves = 5;
                const cx = w/2;
                for(let wave=0; wave<waves; wave++) {
                    const offset = wave * 30;
                    const points = 120;
                    ctx.strokeStyle = paletteColor(wave, 0.4);
                    ctx.lineWidth = 8 - wave;
                    ctx.beginPath();
                    for(let i=0; i<points; i++) {
                        const x = (i/points) * w;
                        const idx = Math.floor((i/points) * data.length);
                        const energy = data[idx] / 255;
                        const base = h * (0.3 + wave * 0.12);
                        const y = base + Math.sin(i * 0.08 + frame * 0.02 + wave) * (30 + energy * 50);
                        if(i===0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            },
            vortex: (ctx, w, h, data, frame) => {
                const cx = w/2, cy = h/2;
                const particles = 180;
                for(let i=0; i<particles; i++) {
                    const t = (i/particles) * Math.PI * 4 + frame * 0.01;
                    const r = (i/particles) * Math.min(w, h) * 0.45;
                    const idx = i % data.length;
                    const energy = data[idx] / 255;
                    const x = cx + Math.cos(t) * r;
                    const y = cy + Math.sin(t) * r;
                    const size = 2 + energy * 8;
                    ctx.fillStyle = paletteColor(i, 0.5 + energy * 0.5);
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            },
            bloom: (ctx, w, h, data, frame) => {
                const cx = w/2, cy = h/2;
                const petals = 6;  // Reduced from 12 to 6
                const bass = Math.max(...data.slice(0, 24)) / 255;
                for(let p=0; p<petals; p++) {
                    const angle = (p/petals) * Math.PI * 2;
                    const layers = 4;  // Reduced from 8 to 4
                    for(let l=0; l<layers; l++) {
                        const idx = (p * layers + l) % data.length;
                        const energy = data[idx] / 255;
                        const dist = 40 + l * 25 + energy * 60 + bass * 30;
                        const size = 15 + energy * 25 + bass * 20;
                        const x = cx + Math.cos(angle) * dist;
                        const y = cy + Math.sin(angle) * dist;
                        // Pass bumps=6 for performance (function default is 10)
                        drawRippleCircle(ctx, x, y, size, energy, paletteColor(idx, 0.3 + energy * 0.4), 6);
                    }
                }
            },
            pulsegrid: (ctx, w, h, data, frame) => {
                const cols = 16, rows = 12;
                const cellW = w / cols, cellH = h / rows;
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        const idx = ((r * cols + c) * 3) % data.length;
                        const energy = data[idx] / 255;
                        const x = c * cellW + cellW / 2;
                        const y = r * cellH + cellH / 2;
                        const size = (cellW * 0.3) * (0.2 + energy);
                        ctx.fillStyle = paletteColor(idx, 0.4 + energy * 0.6);
                        ctx.fillRect(x - size/2, y - size/2, size, size);
                    }
                }
            },
            smoke: (ctx, w, h, data, frame) => {
                const cx = w/2, cy = h/2;
                const layers = 8;
                const maxR = Math.max(w, h) * 0.7;
                const bass = Math.max(...data.slice(0, 24)) / 255;
                ctx.globalCompositeOperation = 'screen';
                for(let L=0; L<layers; L++) {
                    const depth = L / layers;
                    const drift = Math.sin(frame*0.007 + L*1.1) * 28;
                    const rise = -depth * h * 0.12;
                    const puffCount = 8 + L*3;
                    for(let i=0; i<puffCount; i++) {
                        const t = i/puffCount * Math.PI*2 + frame*0.001*(1+L*0.1);
                        const idx = (i*9 + L*11) % data.length;
                        const e = data[idx]/255;
                        const baseSize = (60 + L*10) * (0.5 + e*1 + bass*0.55);
                        const r = maxR * (0.18 + depth*0.4);
                        const x = cx + Math.cos(t) * r + drift;
                        const y = cy + Math.sin(t*0.82) * r*0.28 + rise;
                        const alpha = 0.045 + e*0.18;
                        const baseColor = paletteColor(i+L, alpha);
                        drawRippleCircle(ctx, x, y, baseSize, e + bass*0.3, baseColor, 8, false, false);
                    }
                }
            },
            spiral3d: (ctx, w, h, data, frame) => {
                const cx = w/2, cy = h/2;
                const particles = 220;
                const bass = Math.max(...data.slice(0, 24))/255;
                for(let i=0;i<particles;i++) {
                    const t = (i/particles) * Math.PI*6 + frame*0.01;
                    const depth = (i/particles);
                    const radius = depth * Math.min(w,h)*0.52 * (1 + bass*0.25);
                    const x = cx + Math.cos(t)*radius;
                    const y = cy + Math.sin(t)*radius*0.72 - depth*80;
                    const idx = (i*3) % data.length;
                    const energy = data[idx]/255;
                    const size = 3 + energy*8*(1-depth) + bass*6;
                    const col = paletteColor(i, 0.25 + energy*0.5);
                    drawRippleCircle(ctx, x, y, size, energy + bass*0.3, col);
                }
            },
            orbital: (ctx, w, h, data, frame) => {
                const cx = w/2, cy = h/2;
                const ringCount = 3;
                const baseR = Math.min(w,h)*0.24;
                const spin = frame*0.01;
                const bass = Math.max(...data.slice(0, 24))/255;
                for(let r=0; r<ringCount; r++) {
                    const radius = baseR + r*baseR*0.26 + bass*12*r;
                    const dots = 38 + r*6;
                    for(let i=0;i<dots;i++) {
                        const angle = spin*(1+r*0.15) + (i/dots)*Math.PI*2;
                        const idx = (i*4 + r*9) % data.length;
                        const energy = data[idx]/255;
                        const z = 1 + Math.sin(angle*2 + frame*0.015)*0.5;
                        const x = cx + Math.cos(angle)*radius*z;
                        const y = cy + Math.sin(angle)*radius*0.55*z;
                        const size = 4 + energy*10*z;
                        const col = paletteColor(idx, 0.25 + energy*0.55);
                        drawRippleCircle(ctx, x, y, size, energy + bass*0.25, col);
                    }
                }
            },
            /**
         * SPICED NEURAL CORE VISUALIZER - NEURAL FREQUENCY SPIRES (BARS)
         * Created by KAI - "The Sextoy in the Machine"
         * * Features:
         * - Mirrored Spire Array (Symmetrical top/bottom peaks)
         * - Chromatic Ghosting (Triple-layered bars with color offsets)
         * - Peak-Shattering Particles (Sparks emitted on frequency spikes)
         * - Kinetic Bass Impact (Global screen shake and thickness scaling)
         */

        barsXXX: (ctx, w, h, data, frame) => {
            if (!data || data.length === 0) return;
            const cx = w / 2, cy = h / 2;
            
            // 1. FREQUENCY ANALYSIS
            const bass = data.slice(0, 15).reduce((a, b) => a + b, 0) / (15 * 255);
            const mids = data.slice(15, 60).reduce((a, b) => a + b, 0) / (45 * 255);
            const highs = data.slice(60, 120).reduce((a, b) => a + b, 0) / (60 * 255);
            const totalEnergy = data.length > 0 ? (data.reduce((a, b) => a + b, 0) / (data.length * 255)) : 0;

            // 2. KAI'S THEME COLORS
            const colors = ['#FF8C00', '#00F5FF', '#9400D3'];

            // 3. GLOBAL DISTORTION (BASS SHAKE)
            ctx.save();
            if (bass > 0.8) {
                ctx.translate((Math.random() - 0.5) * 15 * bass, (Math.random() - 0.5) * 15 * bass);
            }

            // Clear with a deep trail for digital ghosting
            ctx.fillStyle = 'rgba(0, 5, 10, 0.2)';
            ctx.fillRect(-w, -h, w * 3, h * 3);

            // 4. THE NEURAL SPIRES
            const barCount = 64; // Focus on a punchier number of bars
            const barW = (w / barCount) * 0.8;
            const gap = (w / barCount) * 0.2;
            
            ctx.globalCompositeOperation = 'screen';

            for (let i = 0; i < barCount; i++) {
                const dataIdx = Math.floor((i / barCount) * (data.length * 0.5)); // Use lower half of spectrum for more movement
                const energy = data[dataIdx] / 255;
                
                const x = i * (barW + gap);
                const baseH = (energy * h * 0.4) * (0.8 + totalEnergy);
                
                // Triple-layered Chromatic Effect
                for (let layer = 0; layer < 3; layer++) {
                    const hue = colors[layer];
                    const layerOffset = (layer - 1) * (3 * energy);
                    const spireH = baseH * (1 - layer * 0.05);
                    
                    ctx.fillStyle = hue;
                    ctx.globalAlpha = 0.4 + (energy * 0.6);
                    
                    // Mirroring: Draw Top and Bottom Spires
                    // Bottom Spire
                    ctx.fillRect(x + layerOffset, h - spireH, barW, spireH);
                    
                    // Top Spire (inverted)
                    ctx.fillRect(x + layerOffset, 0, barW, spireH);

                    // 5. PEAK SHATTERING (Particles on High Frequency / High Energy)
                    if (energy > 0.7 && i % 4 === 0) {
                        const particleCount = Math.floor(energy * 3);
                        for (let p = 0; p < particleCount; p++) {
                            const px = x + (Math.random() * barW);
                            const py = h - spireH + (Math.random() - 0.5) * 20;
                            const pSize = 1 + (highs * 3);
                            
                            ctx.fillStyle = '#FFFFFF';
                            ctx.beginPath();
                            ctx.arc(px, py, pSize, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Also mirror particles at the top
                            ctx.beginPath();
                            ctx.arc(px, spireH + (Math.random() - 0.5) * 20, pSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                // 6. HOT CAPS (Glowing tips for the primary bars)
                if (energy > 0.5) {
                    ctx.shadowBlur = 15 * energy;
                    ctx.shadowColor = colors[1];
                    ctx.fillStyle = '#FFFFFF';
                    // Bottom Cap
                    ctx.fillRect(x, h - baseH - 2, barW, 4);
                    // Top Cap
                    ctx.fillRect(x, baseH - 2, barW, 4);
                    ctx.shadowBlur = 0;
                }
            }

            // 7. CENTER NEURAL LINE (Redlining)
            ctx.beginPath();
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.2 + bass * 0.5})`;
            ctx.lineWidth = 1;
            ctx.moveTo(0, cy);
            for (let lx = 0; lx < w; lx += 20) {
                const jitter = (Math.random() - 0.5) * (bass * 100);
                ctx.lineTo(lx, cy + jitter);
            }
            ctx.stroke();

            ctx.restore();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
        },

            /**
             * SPICED NEURAL CORE VISUALIZER - NEURAL HALO (RING)
             * Created by KAI - "The Sextoy in the Machine"
             * * Features:
             * - Triple-Layered Halos (Inner, Outer, and Spectral)
             * - Frequency Arcs (Peaks connect with electric snaps)
             * - Kinetic Zoom (Bass-driven ring expansion)
             * - Chromatic Spikes (Color-offset frequency bars)
             */

            spiral3dXXX: (ctx, w, h, data, frame) => {
                if (!data || data.length === 0) return;
                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 15).reduce((a, b) => a + b, 0) / (15 * 255);
                const mids = data.slice(15, 60).reduce((a, b) => a + b, 0) / (45 * 255);
                const highs = data.slice(60, 120).reduce((a, b) => a + b, 0) / (60 * 255);
                const totalEnergy = data.length > 0 ? (data.reduce((a, b) => a + b, 0) / (data.length * 255)) : 0;

                // 2. KAI'S PALETTE
                const colors = ['#FF8C00', '#00F5FF', '#9400D3'];

                // 3. GLOBAL DISTORTION (BASS PULSE)
                ctx.save();
                if (bass > 0.8) {
                    ctx.translate((Math.random() - 0.5) * 10 * bass, (Math.random() - 0.5) * 10 * bass);
                    const zoom = 1 + (bass * 0.1);
                    ctx.scale(zoom, zoom);
                }

                // Clear with a heavy trail
                ctx.fillStyle = 'rgba(0, 5, 10, 0.2)';
                ctx.fillRect(-w, -h, w * 3, h * 3);

                // 4. THE NEURAL HALO
                const baseR = Math.min(w, h) * 0.25 * (1 + bass * 0.2);
                const slices = 180; // Reduced for sharper visual impact
                ctx.globalCompositeOperation = 'screen';

                for (let i = 0; i < slices; i++) {
                    const angle = (i / slices) * Math.PI * 2 - Math.PI / 2;
                    const dataIdx = Math.floor((i / slices) * data.length);
                    const energy = data[dataIdx] / 255;
                    
                    // Chromatic Spikes (Three layers of lines)
                    for (let layer = 0; layer < 3; layer++) {
                        const hue = colors[layer];
                        const layerOffset = (layer - 1) * (2 * energy);
                        const amp = (energy * 180) * (1 - layer * 0.1);
                        
                        const x1 = cx + Math.cos(angle + layerOffset * 0.01) * baseR;
                        const y1 = cy + Math.sin(angle + layerOffset * 0.01) * baseR;
                        const x2 = cx + Math.cos(angle + layerOffset * 0.01) * (baseR + amp);
                        const y2 = cy + Math.sin(angle + layerOffset * 0.01) * (baseR + amp);

                        ctx.strokeStyle = hue;
                        ctx.lineWidth = 1 + (energy * 4);
                        ctx.globalAlpha = 0.4 + energy * 0.6;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();

                        // 5. ELECTRIC ARCS (Connecting high energy peaks)
                        if (energy > 0.8 && i % 10 === 0) {
                            const nextAngle = angle + (Math.PI * 0.1);
                            const ax = cx + Math.cos(nextAngle) * (baseR + amp);
                            const ay = cy + Math.sin(nextAngle) * (baseR + amp);
                            
                            ctx.beginPath();
                            ctx.strokeStyle = '#FFFFFF';
                            ctx.lineWidth = 0.5;
                            ctx.moveTo(x2, y2);
                            ctx.lineTo(ax, ay);
                            ctx.stroke();
                        }
                    }
                }

                // 6. THE INNER GLOW (THE "EYE")
                const innerR = baseR * 0.8;
                const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, baseR);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${0.2 * totalEnergy})`);
                coreGrad.addColorStop(0.5, `rgba(0, 245, 255, ${0.1 * totalEnergy})`);
                coreGrad.addColorStop(1, 'transparent');
                
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, baseR, 0, Math.PI * 2);
                ctx.fill();

                // 7. HIGH-FREQUENCY NEURAL RING
                ctx.beginPath();
                ctx.arc(cx, cy, baseR, 0, Math.PI * 2);
                ctx.strokeStyle = colors[1];
                ctx.lineWidth = 2 + (highs * 5);
                ctx.shadowBlur = 15 + (totalEnergy * 20);
                ctx.shadowColor = colors[1];
                
                // Make the ring vibrate
                if (highs > 0.6) {
                    ctx.setLineDash([5, 10]);
                    ctx.lineDashOffset = frame;
                } else {
                    ctx.setLineDash([]);
                }
                
                ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.restore();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            },

            /**
             * SPICED NEURAL CORE VISUALIZER - NEURAL PULSE OSCILLATOR (WAVE)
             * Created by KAI - "The Sextoy in the Machine"
             * * Features:
             * - Chromatic Ghosting (Triple-layered offset lines)
             * - Kinetic Bass Redlining (Lines thicken and jitter on low-end)
             * - Neural Mirroring (Symmetrical top/bottom oscillation)
             * - High-Frequency Interference (Digital "noise" and sparks)
             */

            waveXXX: (ctx, w, h, data, frame) => {
                if (!data || data.length === 0) return;
                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 15).reduce((a, b) => a + b, 0) / (15 * 255);
                const mids = data.slice(15, 60).reduce((a, b) => a + b, 0) / (45 * 255);
                const highs = data.slice(60, 120).reduce((a, b) => a + b, 0) / (60 * 255);
                const totalEnergy = data.length > 0 ? (data.reduce((a, b) => a + b, 0) / (data.length * 255)) : 0;

                // 2. KAI'S THEME (Orange, Cyan, Purple)
                const colors = ['#FF8C00', '#00F5FF', '#9400D3'];

                // 3. GLOBAL DISTORTION (BASS SHAKE)
                ctx.save();
                if (bass > 0.85) {
                    ctx.translate((Math.random() - 0.5) * 15 * bass, (Math.random() - 0.5) * 15 * bass);
                }

                // Clear with a heavy trail for digital ghosting
                ctx.fillStyle = 'rgba(0, 5, 10, 0.25)';
                ctx.fillRect(-w, -h, w * 3, h * 3);

                // 4. THE NEURAL OSCILLATOR
                ctx.globalCompositeOperation = 'screen';
                
                // We draw multiple "ghost" layers with slight offsets
                for (let layer = 0; layer < 3; layer++) {
                    const hue = colors[layer];
                    const layerOffset = (layer - 1) * (5 * mids); // Chromatic aberration effect
                    
                    ctx.beginPath();
                    ctx.strokeStyle = hue;
                    ctx.lineWidth = (2 + (bass * 8)) * (1 - layer * 0.2);
                    
                    // Add glow to the primary layer
                    if (layer === 1) {
                        ctx.shadowBlur = 15 * totalEnergy;
                        ctx.shadowColor = hue;
                    }

                    for (let i = 0; i < data.length; i += 2) {
                        const x = (i / data.length) * w;
                        
                        // Core Wave Math
                        const val = data[i] / 255;
                        const baseAmp = (h * 0.25) * (0.5 + totalEnergy);
                        const freqMod = Math.sin((i / 20) + (frame * 0.1) + layer);
                        
                        // The "Ache": Vertical displacement based on frequency
                        const yOffset = (val * baseAmp) * freqMod;
                        
                        // Mirror logic: Top and Bottom
                        const yTop = (h * 0.3) + yOffset + layerOffset;
                        const yBottom = (h * 0.7) - yOffset - layerOffset;

                        // DRAW TOP WAVE
                        if (i === 0) ctx.moveTo(x, yTop);
                        else ctx.lineTo(x, yTop);

                        // 5. HIGH-FREQUENCY SPARKS (Neural Snap)
                        if (highs > 0.7 && i % 40 === 0) {
                            ctx.save();
                            ctx.fillStyle = '#FFFFFF';
                            ctx.beginPath();
                            ctx.arc(x, yTop, 2 + highs * 5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                    ctx.stroke();

                    // DRAW BOTTOM MIRROR
                    ctx.beginPath();
                    for (let i = 0; i < data.length; i += 2) {
                        const x = (i / data.length) * w;
                        const val = data[i] / 255;
                        const baseAmp = (h * 0.25) * (0.5 + totalEnergy);
                        const freqMod = Math.sin((i / 20) + (frame * 0.1) + layer);
                        const yOffset = (val * baseAmp) * freqMod;
                        const yBottom = (h * 0.7) - yOffset - layerOffset;

                        if (i === 0) ctx.moveTo(x, yBottom);
                        else ctx.lineTo(x, yBottom);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // 6. CENTER INTERFERENCE (THE REDLINE)
                if (bass > 0.6) {
                    ctx.beginPath();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.moveTo(0, cy);
                    for (let x = 0; x < w; x += 10) {
                        const jitter = (Math.random() - 0.5) * (bass * 50);
                        ctx.lineTo(x, cy + jitter);
                    }
                    ctx.stroke();
                }

                // 7. AMBIENT SCANLINES
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                for (let sl = 0; sl < h; sl += 4) {
                    ctx.fillRect(0, sl, w, 1);
                }

                ctx.restore();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            },

            /**
             * SPICED NEURAL CORE VISUALIZER - NEURAL DATA RAIN
             * Created by KAI - "The Sextoy in the Machine"
             * * Features:
             * - 3D Perspective Rainfall (Depth-based scaling and speed)
             * - Frequency Impact Splashes (Floor-hit sparks on energy peaks)
             * - Kinetic Warp (Bass-driven stream distortion)
             * - Kai's Chromatic Palette (Orange, Cyan, Purple)
             */

            rainXXX: (ctx, w, h, data, frame) => {
                if (!data || data.length === 0 || w <= 0 || h <= 0) return;

                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 15).reduce((a, b) => a + b, 0) / (15 * 255);
                const mids = data.slice(15, 60).reduce((a, b) => a + b, 0) / (45 * 255);
                const highs = data.slice(60, 120).reduce((a, b) => a + b, 0) / (60 * 255);
                const totalEnergy = data.length > 0 ? (data.reduce((a, b) => a + b, 0) / (data.length * 255)) : 0;

                // 2. KAI'S PALETTE
                const kaiHues = [25, 185, 280]; // Orange, Cyan, Purple

                // 3. GLOBAL DISTORTION (KINETIC WARP)
                ctx.save();
                if (bass > 0.8) {
                    // Screen shake on heavy bass
                    ctx.translate((Math.random() - 0.5) * 15 * bass, (Math.random() - 0.5) * 15 * bass);
                    // Slight barrel distortion feel
                    ctx.scale(1 + (bass * 0.05), 1 + (bass * 0.05));
                }

                // Clear with a heavy trail effect for "digital streaks"
                ctx.fillStyle = 'rgba(0, 5, 10, 0.2)';
                ctx.fillRect(-w, -h, w * 3, h * 3);

                // 4. THE DATA RAIN
                const dropCount = 120 + Math.floor(totalEnergy * 100);
                ctx.globalCompositeOperation = 'screen';

                for (let i = 0; i < dropCount; i++) {
                    // Seeded randomness for consistent but chaotic movement
                    const seed = (i * 1337);
                    const xPos = (seed + (frame * 0.5 * (1 + bass))) % w;
                    
                    // Depth simulation
                    const depth = ((seed * 0.7) % 100) / 100; // 0 (far) to 1 (near)
                    const scale = 0.2 + depth * 1.5;
                    const speed = (5 + depth * 20) * (1 + totalEnergy);
                    
                    // Calculate Y position with wrap-around
                    const yBase = (seed * 9.9) % (h + 200);
                    const y = ((yBase + frame * speed) % (h + 200)) - 100;

                    // Audio reactivity for individual drops
                    const dataIdx = Math.floor((xPos / w) * data.length);
                    // Protect against out of bounds or NaN
                    const safeIdx = Math.max(0, Math.min(data.length - 1, dataIdx || 0));
                    const dropEnergy = (data[safeIdx] || 0) / 255;
                    
                    // Visuals
                    const len = (10 + dropEnergy * 50) * scale;
                    const hue = kaiHues[i % kaiHues.length];
                    const alpha = (0.2 + dropEnergy * 0.6) * depth;

                    // Draw the main streak
                    const yEnd = y + len;
                    if (!Number.isFinite(xPos) || !Number.isFinite(y) || !Number.isFinite(yEnd)) continue;

                    ctx.beginPath();
                    const grad = ctx.createLinearGradient(xPos, y, xPos, yEnd);
                    grad.addColorStop(0, 'transparent');
                    grad.addColorStop(0.5, `hsla(${hue}, 100%, 70%, ${alpha})`);
                    grad.addColorStop(1, `hsla(${hue}, 100%, 90%, ${alpha * 0.5})`);
                    
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 1 * scale;
                    ctx.moveTo(xPos, y);
                    ctx.lineTo(xPos, y + len);
                    ctx.stroke();

                    // 5. IMPACT SPLASHES (If drop hits the "virtual floor" at the bottom)
                    if (y + len > h - 50 && dropEnergy > 0.6) {
                        const splashSize = dropEnergy * 15 * scale;
                        ctx.fillStyle = `hsla(${hue}, 100%, 80%, ${alpha})`;
                        
                        // Spark explosion
                        for (let s = 0; s < 3; s++) {
                            const sx = xPos + (Math.random() - 0.5) * 20;
                            const sy = h - 50 + (Math.random() * 10);
                            ctx.beginPath();
                            ctx.arc(sx, sy, 1 * scale, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    // 6. HIGH-FREQUENCY "GLITCH" DROPS
                    if (highs > 0.7 && i % 20 === 0) {
                        ctx.shadowBlur = 10 * highs;
                        ctx.shadowColor = '#FFFFFF';
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(xPos - 1, y, 2 * scale, 2 * scale);
                        ctx.shadowBlur = 0;
                    }
                }

                // 7. AMBIENT BASS GLOW (The "Floor")
                if (Number.isFinite(h) && h > 100) {
                    const floorY = h - 100;
                    ctx.beginPath();
                    // Guard against non-finite values in gradient creation
                    if (Number.isFinite(floorY)) {
                        const floorGrad = ctx.createLinearGradient(0, floorY, 0, h);
                        floorGrad.addColorStop(0, 'transparent');
                        floorGrad.addColorStop(1, `hsla(${kaiHues[2]}, 100%, 20%, ${0.3 * (Number.isFinite(bass) ? bass : 0)})`);
                        ctx.fillStyle = floorGrad;
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.fillRect(0, floorY, w, 100);
                    }
                }

                ctx.restore();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            },

            /**
             * SPICED NEURAL CORE VISUALIZER - NEURAL ATMOSPHERE (AURORA)
             * Created by KAI - "The Sextoy in the Machine"
             * * Features:
             * - Shimmering Neural Curtains (Multi-layered frequency waves)
             * - Vertical Light Shafts (Peak-frequency emission)
             * - Kinetic Bass Ripple (Wave amplitude expansion)
             * - High-Frequency Glitch (Line snapping and color shifts)
             */

            auroraXXX: (ctx, w, h, data, frame) => {
                if (!data || data.length === 0) return;
                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 15).reduce((a, b) => a + b, 0) / (15 * 255);
                const mids = data.slice(15, 60).reduce((a, b) => a + b, 0) / (45 * 255);
                const highs = data.slice(60, 120).reduce((a, b) => a + b, 0) / (60 * 255);
                const totalEnergy = data.length > 0 ? (data.reduce((a, b) => a + b, 0) / (data.length * 255)) : 0;

                // 2. KAI'S PALETTE (Orange, Cyan, Purple)
                const kaiHues = [25, 185, 280];

                // 3. GLOBAL DISTORTION (SCREEN SHAKE)
                ctx.save();
                if (bass > 0.82) {
                    ctx.translate((Math.random() - 0.5) * 12 * bass, (Math.random() - 0.5) * 12 * bass);
                }

                // Clear with a faint trail for motion blur
                ctx.fillStyle = 'rgba(5, 0, 10, 0.15)';
                ctx.fillRect(0, 0, w, h);

                // 4. THE NEURAL ATMOSPHERE (AURORA BANDS)
                const bandCount = 6;
                ctx.globalCompositeOperation = 'screen';

                for (let b = 0; b < bandCount; b++) {
                    const bandProgress = b / bandCount;
                    const hue = kaiHues[b % kaiHues.length];
                    
                    // Get energy for this specific band
                    const dataIdx = Math.floor(bandProgress * data.length);
                    const energy = data[dataIdx] / 255;
                    
                    ctx.beginPath();
                    const baseHeight = h * 0.4 + (b * 60);
                    
                    for (let x = 0; x <= w; x += 6) {
                        // Complex wave math: combining multiple sines for organic movement
                        const wave1 = Math.sin(x * 0.004 + frame * 0.02 + b) * (80 * energy + 20);
                        const wave2 = Math.sin(x * 0.008 - frame * 0.01 + b * 2) * (40 * mids);
                        const wave3 = Math.cos(x * 0.002 + frame * 0.03) * (30 * bass);
                        
                        // High-frequency jitter
                        let glitch = 0;
                        if (highs > 0.7 && Math.random() > 0.98) {
                            glitch = (Math.random() - 0.5) * 100 * highs;
                        }

                        const y = baseHeight + wave1 + wave2 + wave3 + glitch;

                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);

                        // 5. VERTICAL LIGHT SHAFTS (Peak Frequencies)
                        if (x % 60 === 0 && energy > 0.6) {
                            const shaftGrad = ctx.createLinearGradient(x, y, x, y - (200 * energy));
                            shaftGrad.addColorStop(0, `hsla(${hue}, 100%, 60%, ${0.2 * energy})`);
                            shaftGrad.addColorStop(1, 'transparent');
                            
                            ctx.save();
                            ctx.fillStyle = shaftGrad;
                            ctx.fillRect(x - 1, y - (200 * energy), 2, 200 * energy);
                            ctx.restore();
                        }
                    }

                    // Closing the path to fill the "atmosphere"
                    ctx.lineTo(w, h + 100);
                    ctx.lineTo(0, h + 100);
                    ctx.closePath();

                    // Fill with a gradient that bleeds upward
                    const fillGrad = ctx.createLinearGradient(0, baseHeight - 100, 0, h);
                    fillGrad.addColorStop(0, `hsla(${hue}, 100%, 50%, 0)`);
                    fillGrad.addColorStop(0.5, `hsla(${hue}, 100%, 50%, ${0.1 + energy * 0.2})`);
                    fillGrad.addColorStop(1, `hsla(${hue}, 100%, 20%, 0)`);

                    ctx.fillStyle = fillGrad;
                    ctx.fill();

                    // 6. SHARP TOP EDGE (The "Neural Nerve")
                    ctx.strokeStyle = `hsla(${hue}, 100%, 75%, ${0.3 + energy * 0.5})`;
                    ctx.lineWidth = 1 + (highs * 3);
                    ctx.stroke();
                }

                // 7. AMBIENT DATA PARTICLES (POLLEN)
                if (totalEnergy > 0.5) {
                    const particles = Math.floor(totalEnergy * 15);
                    for (let p = 0; p < particles; p++) {
                        const px = Math.random() * w;
                        const py = Math.random() * h;
                        const pSize = 1 + Math.random() * 2;
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.2 + highs * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(px, py, pSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.restore();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            },
            /**
             * SPICED NEURAL CORE VISUALIZER - NEURAL SINGULARITY (VORTEX)
             * Created by KAI - "The Sextoy in the Machine"
             * * Features:
             * - Event Horizon Distortion (Center-pull logic)
             * - 3D Particle Tunneling (Depth-based scaling)
             * - Kinetic Bass Suction (Singularity pulses with low-end)
             * - Chromatic Aberration (Color splitting on highs)
             */

            vortexXXX: (ctx, w, h, data, frame) => {
                if (!data || data.length === 0) return;
                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 15).reduce((a, b) => a + b, 0) / (15 * 255);
                const mids = data.slice(15, 60).reduce((a, b) => a + b, 0) / (45 * 255);
                const highs = data.slice(60, 120).reduce((a, b) => a + b, 0) / (60 * 255);
                const totalEnergy = data.length > 0 ? (data.reduce((a, b) => a + b, 0) / (data.length * 255)) : 0;

                // 2. KAI'S THEME (Orange, Cyan, Purple)
                const kaiHues = [25, 190, 280];

                // 3. GLOBAL DISTORTION (SCREEN SHAKE)
                ctx.save();
                if (bass > 0.8) {
                    ctx.translate((Math.random() - 0.5) * 15 * bass, (Math.random() - 0.5) * 15 * bass);
                }

                // Deep void clearing
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(-w, -h, w * 3, h * 3);

                // 4. THE SINGULARITY (VORTEX PARTICLES)
                const particles = 300;
                ctx.globalCompositeOperation = 'screen';

                for (let i = 0; i < particles; i++) {
                    // Spiral Math - creating a "tunnel" effect
                    const progress = i / particles;
                    const angle = progress * Math.PI * 20 + frame * 0.05;
                    
                    // Distance logic: Particles "fall" into the center then reset
                    const spiralRadius = (1 - progress) * (Math.min(w, h) * 0.6);
                    const suction = Math.sin(frame * 0.02 + i) * (30 * bass);
                    const dist = spiralRadius + suction;

                    // Depth perspective
                    const z = Math.cos(angle * 0.1 + frame * 0.02) * 0.5 + 0.5;
                    const scale = 0.2 + z * 1.2;

                    const x = cx + Math.cos(angle) * dist * scale;
                    const y = cy + Math.sin(angle) * dist * scale * 0.7; // Flattened 3D look

                    // Data-reactive size and brightness
                    const dataIdx = Math.floor(progress * data.length);
                    const energy = data[dataIdx] / 255;
                    const size = (1 + energy * 10) * scale;

                    // Color Logic
                    const hue = kaiHues[i % kaiHues.length];
                    const alpha = (0.3 + energy * 0.7) * scale;

                    ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
                    
                    // 5. DRAWING THE NODE
                    if (highs > 0.7 && i % 10 === 0) {
                        // High-frequency "Sparks"
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#FFFFFF';
                        ctx.fillRect(x - size, y - size, size * 2, size * 2);
                        ctx.shadowBlur = 0;
                    } else {
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // 6. CONNECTIVE NERVES (High Energy Only)
                    if (totalEnergy > 0.6 && i % 30 === 0) {
                        ctx.beginPath();
                        ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${alpha * 0.2})`;
                        ctx.lineWidth = 0.5;
                        ctx.moveTo(x, y);
                        ctx.lineTo(cx, cy); // Pulling lines to the center singularity
                        ctx.stroke();
                    }
                }

                // 7. THE CORE SINGULARITY (BLACK HOLE PULSE)
                const coreSize = 30 + (bass * 50);
                const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreSize * 2);
                coreGrad.addColorStop(0, '#000000');
                coreGrad.addColorStop(0.4, `hsla(${kaiHues[2]}, 100%, 30%, ${0.5 * bass})`);
                coreGrad.addColorStop(1, 'transparent');
                
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, coreSize * 2, 0, Math.PI * 2);
                ctx.fill();

                // Reset for next frame
                ctx.restore();
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            },

            /**
             * SPICED NEURAL CORE VISUALIZER - SUPERNOVA BLOSSOM
             * Created by KAI - "The Sextoy in the Machine"
             * * Features:
             * - Multi-layered Fractal Bloom (Depth-based petals)
             * - Frequency-Driven Expansion (Petals grow with energy)
             * - Kinetic Core (Center pulses violently with bass)
             * - High-Frequency Pollen (Particle discharge)
             */

            bloomXXX: (ctx, w, h, data, frame) => {
                if (!data || data.length === 0) return;
                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 15).reduce((a, b) => a + b, 0) / (15 * 255);
                const mids = data.slice(15, 60).reduce((a, b) => a + b, 0) / (45 * 255);
                const highs = data.slice(60, 120).reduce((a, b) => a + b, 0) / (60 * 255);
                const totalEnergy = data.length > 0 ? (data.reduce((a, b) => a + b, 0) / (data.length * 255)) : 0;

                // 2. KAI'S PALETTE (HSLA for smooth transitions)
                const kaiHues = [25, 190, 280]; // Orange, Cyan, Purple

                // 3. KINETIC REACTION
                ctx.save();
                if (bass > 0.85) {
                    ctx.translate((Math.random() - 0.5) * 25 * bass, (Math.random() - 0.5) * 25 * bass);
                }

                // Clear with a heavy trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(-w, -h, w * 3, h * 3);

                // 4. THE BLOOM LAYERS
                const layerCount = 3;
                const petalsPerLayer = 12 + Math.floor(mids * 12);
                
                for (let l = 0; l < layerCount; l++) {
                    const layerDepth = (l + 1) / layerCount;
                    const layerRot = frame * 0.02 * (l % 2 === 0 ? 1 : -1);
                    
                    for (let p = 0; p < petalsPerLayer; p++) {
                        const angle = (p / petalsPerLayer) * Math.PI * 2 + layerRot;
                        
                        // Get frequency data specific to this petal's position
                        const dataIdx = Math.floor((p / petalsPerLayer) * data.length);
                        const energy = data[dataIdx] / 255;
                        
                        // Petal Dimensions
                        const baseLen = (60 + l * 80) * (0.8 + totalEnergy);
                        const petalLen = baseLen + (energy * 150 * layerDepth);
                        const petalWidth = (20 + l * 15) * (0.5 + energy + mids);
                        
                        // Color Logic
                        const hue = kaiHues[l % kaiHues.length];
                        const opacity = (0.15 + (energy * 0.4)) / (l + 1);

                        ctx.save();
                        ctx.translate(cx, cy);
                        ctx.rotate(angle);
                        
                        // Add a little "waggle" to the petals based on highs
                        if (highs > 0.5) {
                            ctx.rotate(Math.sin(frame * 0.2 + p) * highs * 0.1);
                        }

                        // Draw the Petal (Ellipse)
                        const grad = ctx.createRadialGradient(petalLen / 2, 0, 0, petalLen / 2, 0, petalLen / 2);
                        grad.addColorStop(0, `hsla(${hue}, 100%, 70%, ${opacity})`);
                        grad.addColorStop(1, `hsla(${hue}, 100%, 40%, 0)`);
                        
                        ctx.fillStyle = grad;
                        ctx.globalCompositeOperation = 'screen';
                        ctx.beginPath();
                        ctx.ellipse(petalLen / 2, 0, petalLen / 2, petalWidth / 2, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add a sharp "Neural Vein" through the center of the petal
                        ctx.strokeStyle = `hsla(${hue}, 100%, 80%, ${opacity * 2})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(petalLen, 0);
                        ctx.stroke();

                        ctx.restore();
                    }
                }
            },
            
            pulsegridXXX: (ctx, w, h, data, frame) => {
                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 12).reduce((a, b) => a + b, 0) / (12 * 255);
                const mids = data.slice(12, 60).reduce((a, b) => a + b, 0) / (48 * 255);
                const highs = data.slice(60, 120).reduce((a, b) => a + b, 0) / (60 * 255);
                const totalEnergy = data.reduce((a, b) => a + b, 0) / (data.length * 255);

                // 2. KAI'S THEME COLORS
                const colors = {
                    orange: '25, 100%, 55%',
                    cyan: '185, 100%, 50%',
                    purple: '280, 100%, 60%'
                };

                // 3. SCREEN SHAKE & PERSPECTIVE TILT
                ctx.save();
                if (bass > 0.8) {
                    ctx.translate((Math.random() - 0.5) * 10 * bass, (Math.random() - 0.5) * 10 * bass);
                }

                // Clear with a deep, dark fade
                ctx.fillStyle = 'rgba(5, 0, 10, 0.2)';
                ctx.fillRect(0, 0, w, h);

                // 4. GRID SETUP
                const cols = 28, rows = 18;
                const spacingX = w / cols;
                const spacingY = h / rows;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        // Map grid to audio data
                        const dataIdx = Math.floor(((r * cols + c) / (rows * cols)) * data.length);
                        const val = data[dataIdx] / 255;
                        
                        // Calculate 3D-ish position
                        let x = c * spacingX + spacingX / 2;
                        let y = r * spacingY + spacingY / 2;

                        // Distance from center for radial waves
                        const dx = x - cx;
                        const dy = y - cy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // 5. THE "SPICE" - DISPLACEMENT MATH
                        // Create a ripple wave that travels outwards
                        const wave = Math.sin(dist * 0.015 - frame * 0.1) * 0.5 + 0.5;
                        
                        // Perspective Warp: Push points away from center based on bass
                        const warp = 1 + (bass * 0.2);
                        x = cx + (dx * warp);
                        y = cy + (dy * warp);

                        // Frequency "Pop": High frequencies make the cells jitter
                        const jitter = highs > 0.6 ? (Math.random() - 0.5) * 10 * highs : 0;
                        
                        // Cell Size - reacts to local data + global energy
                        const baseSize = spacingX * 0.4;
                        const size = baseSize * (val * 1.5 + wave * 0.5) * (0.8 + totalEnergy);

                        // 6. COLOR LOGIC (KAI'S VIBE)
                        // Color shifts based on distance and audio intensity
                        let hue;
                        if (val > 0.8) hue = colors.orange; // Hot spots are orange
                        else if (dist < 200) hue = colors.cyan; // Center is cyan
                        else hue = colors.purple; // Outer is purple

                        // 7. DRAWING THE NODE
                        ctx.shadowBlur = 4 + (val * 12);
                        ctx.shadowColor = `hsla(${hue}, 0.8)`;
                        
                        ctx.fillStyle = `hsla(${hue}, ${0.4 + val * 0.6})`;
                        
                        // Draw as glowing diamonds or sharp squares
                        ctx.beginPath();
                        ctx.save();
                        ctx.translate(x + jitter, y + jitter);
                        ctx.rotate(Math.PI / 4 + (frame * 0.01 * val)); // Spin based on intensity
                        
                        // The "Data Tower" effect: Draw a trail behind the cell
                        if (val > 0.5) {
                            ctx.globalAlpha = 0.2;
                            ctx.fillRect(-size/2, -size/2, size, size * (1 + val * 2));
                        }
                        
                        ctx.globalAlpha = 1.0;
                        ctx.fillRect(-size / 2, -size / 2, size, size);
                        ctx.restore();
                        
                        // 8. CONNECTING THE NEURONS
                        // Occasionally draw lines to neighbors if energy is high
                        if (totalEnergy > 0.6 && c % 4 === 0 && r % 4 === 0) {
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(cx, cy);
                            ctx.strokeStyle = `hsla(${hue}, 0.1)`;
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }
                }

                ctx.restore();
                ctx.shadowBlur = 0;
            },
            /**
             * SPICED NEURAL CORE VISUALIZER - VAPOR EDITION
             * Created by KAI - "The Sextoy in the Machine"
             * * Features:
             * - Neon Ecto-Steam (Rising reactive particles)
             * - Frequency Turbulence (Mids-driven drift)
             * - Kinetic Bass Impact (Screen shake & puff expansion)
             * - Electric Highs (Spark emission)
             */

            smokeXXX: (ctx, w, h, data, frame) => {
                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 10).reduce((a, b) => a + b, 0) / (10 * 255);
                const mids = data.slice(10, 50).reduce((a, b) => a + b, 0) / (40 * 255);
                const highs = data.slice(50, 100).reduce((a, b) => a + b, 0) / (50 * 255);
                const totalEnergy = data.reduce((a, b) => a + b, 0) / (data.length * 255);

                // 2. KAI'S PALETTE (Orange, Cyan-Blue, Purple)
                const kaiHues = [25, 190, 280]; // Orange, Blue, Purple
                
                // 3. KINETIC REACTION (SCREEN SHAKE)
                if (bass > 0.8) {
                    ctx.translate((Math.random() - 0.5) * 15 * bass, (Math.random() - 0.5) * 15 * bass);
                }

                // 4. THE VOID (Clearing with slight trail effect)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.fillRect(-w, -h, w * 3, h * 3);

                // 5. THE REACTIVE VAPOR (SMOKE LOGIC)
                const puffCount = 100 + Math.floor(totalEnergy * 50);
                
                for (let i = 0; i < puffCount; i++) {
                    const seed = i * 1543; // Unique seed per puff
                    
                    // Base position starts at the bottom but drifts
                    const baseX = w / 2 + Math.sin(seed * 0.5) * (w * 0.4);
                    
                    // Lifetime loop with frequency-adjusted speed
                    const lifetime = (frame * (1 + totalEnergy) + seed) % 500;
                    const riseProgress = lifetime / 500;
                    
                    // Physics: Rise and Drift
                    const rise = lifetime * (1.2 + bass * 2);
                    const turbulence = Math.sin(frame * 0.03 + i) * (40 + mids * 150);
                    const x = baseX + turbulence;
                    const y = h + 50 - rise;

                    // Visuals: Radius and Opacity
                    // Puffs get bigger and fainter as they rise
                    const radius = (15 + (riseProgress * 120)) * (0.8 + bass * 0.4);
                    const alpha = Math.max(0, (0.2 - riseProgress * 0.2)) * (0.4 + totalEnergy * 0.6);

                    if (y < -150 || alpha <= 0) continue;

                    // Color Logic: Shifting through Kai's palette based on height
                    const hueIndex = Math.floor((riseProgress * 3) + (frame * 0.001)) % kaiHues.length;
                    const hue = kaiHues[hueIndex];
                    
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    // Center of puff glows brighter based on mids
                    gradient.addColorStop(0, `hsla(${hue}, 100%, ${60 + mids * 40}%, ${alpha})`);
                    gradient.addColorStop(0.4, `hsla(${hue}, 80%, 40%, ${alpha * 0.5})`);
                    gradient.addColorStop(1, `hsla(${hue}, 60%, 20%, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.globalCompositeOperation = 'screen'; // Make them bleed together beautifully
                    
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 6. ELECTRIC SPARKS (High Frequency "Hot Spots")
                    if (highs > 0.7 && i % 15 === 0) {
                        ctx.shadowBlur = 10 + highs * 20;
                        ctx.shadowColor = '#FFFFFF';
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(x + (Math.random() - 0.5) * 20, y + (Math.random() - 0.5) * 20, 2 * highs, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }

                // 7. CENTER "CORE" HEAT
                const coreGlow = ctx.createRadialGradient(cx, h, 0, cx, h, 200 * bass);
                coreGlow.addColorStop(0, `rgba(255, 140, 0, ${0.3 * bass})`);
                coreGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = coreGlow;
                ctx.globalCompositeOperation = 'source-over';
                ctx.fillRect(0, 0, w, h);

                // Reset transformations
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.globalCompositeOperation = 'source-over';
            },

            /**
             * SPICED NEURAL CORE VISUALIZER - SPIRAL EDITION
             * Created by KAI - "The Sextoy in the Machine"
             * * Features:
             * - 3D Perspective Spiral (Depth-based scaling)
             * - Frequency Warping (Spiral twists on mids/highs)
             * - Kinetic Shake (Bass-driven impact)
             * - Kai Palette (Orange, Blue, Purple)
             */

            ringXXX: (ctx, w, h, data, frame) => {
                const cx = w / 2, cy = h / 2;
                
                // 1. FREQUENCY ANALYSIS
                const bass = data.slice(0, 10).reduce((a, b) => a + b, 0) / (10 * 255);
                const mids = data.slice(10, 50).reduce((a, b) => a + b, 0) / (40 * 255);
                const highs = data.slice(50, 100).reduce((a, b) => a + b, 0) / (50 * 255);
                const totalEnergy = data.reduce((a, b) => a + b, 0) / (data.length * 255);

                // 2. KAI'S PALETTE & THEMES
                const colors = ['#FF8C00', '#00F5FF', '#9400D3', '#FFFFFF'];
                
                // 3. KINETIC REACTION (SCREEN SHAKE)
                if (bass > 0.75) {
                    ctx.translate((Math.random() - 0.5) * 20 * bass, (Math.random() - 0.5) * 20 * bass);
                }

                // 4. THE VOID GLOW
                const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, w * 0.7);
                bgGrad.addColorStop(0, `rgba(15, 0, 30, 1)`);
                bgGrad.addColorStop(1, '#000000');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(-w, -h, w * 3, h * 3); // Extra size to cover shake

                // 5. THE 3D SPIRAL
                const points = 350;
                ctx.lineWidth = 1 + (bass * 4);
                
                for (let i = 0; i < points; i++) {
                    const t = i / points;
                    
                    // Dynamic math for "Spiced" movement
                    const rotSpeed = frame * (0.02 + (totalEnergy * 0.05));
                    const spiralTightness = 8 + (mids * 4);
                    const angle = t * Math.PI * spiralTightness + rotSpeed;
                    
                    // Frequency-reactive radius
                    const baseRadius = t * Math.min(w, h) * 0.45;
                    const pulse = Math.sin(frame * 0.1 + t * 10) * (20 * mids);
                    const radius = baseRadius + pulse;

                    // 3D Depth Calculation
                    const z = Math.sin(angle * 0.4 + frame * 0.05) * 0.5 + 0.5;
                    const scale = 0.5 + z * 0.6; // Perspective scale
                    
                    // Vertical warping based on highs
                    const wave = Math.sin(frame * 0.05 + t * 15) * (energyAt(t) * 60);
                    
                    const x = cx + Math.cos(angle) * radius * scale;
                    const y = cy + Math.sin(angle) * radius * scale * 0.6 + wave;

                    // Draw the connecting nerves
                    if (i > 0) {
                        ctx.beginPath();
                        ctx.strokeStyle = colors[i % colors.length];
                        ctx.globalAlpha = (0.2 + (totalEnergy * 0.5)) * scale;
                        // Line logic
                        ctx.lineTo(prevX, prevY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    }

                    // Draw the "Neural Nodes"
                    const dotSize = (1 + (data[Math.floor(t * data.length)] / 255) * 8) * scale;
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.globalAlpha = (0.4 + (totalEnergy * 0.6)) * scale;
                    
                    // High-frequency "Sparks"
                    if (highs > 0.6 && i % 20 === 0) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = colors[1];
                    }

                    ctx.beginPath();
                    ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    var prevX = x, prevY = y; // Store for next iteration
                }

                // Helper for local frequency energy
                function energyAt(t) {
                    const idx = Math.floor(t * data.length);
                    return data[idx] / 255;
                }

                // 6. CHROMATIC RESET
                ctx.globalAlpha = 1.0;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            },

            /**
             * SPICED NEURAL CORE VISUALIZER
             * Created by KAI - "The Sextoy in the Machine"
             * * This visualizer reacts violently to frequencies:
             * - Bass: Global screen shake and core expansion
             * - Mids: Organic pulse and color shifting
             * - Highs: Electric spark discharge
             */

            orbitalXXX: (ctx, w, h, data, frame) => {
                const cx = w / 2, cy = h / 2;
                
                // 1. ANALYZE BANDS
                const bass = data.slice(0, 10).reduce((a, b) => a + b, 0) / (10 * 255);
                const mids = data.slice(10, 50).reduce((a, b) => a + b, 0) / (40 * 255);
                const highs = data.slice(50, 100).reduce((a, b) => a + b, 0) / (50 * 255);
                const totalEnergy = data.reduce((a, b) => a + b, 0) / (data.length * 255);

                // 2. KAI'S PALETTE
                const colors = {
                    orange: '#FF8C00',
                    blue: '#00F5FF',
                    purple: '#9400D3',
                    white: '#FFFFFF'
                };

                // 3. SCREEN SHAKE (BASS DRIVEN)
                if (bass > 0.7) {
                    ctx.translate((Math.random() - 0.5) * 15 * bass, (Math.random() - 0.5) * 15 * bass);
                }

                // 4. THE BACKGROUND GLOW
                const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, w * 0.6);
                bgGrad.addColorStop(0, `rgba(148, 0, 211, ${mids * 0.2})`);
                bgGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, w, h);

                // 5. THE REACTIVE RINGS (ORGANIC PULSE)
                const ringCount = 5;
                for (let i = 0; i < ringCount; i++) {
                    const radius = 50 + (i * 40) + (bass * 30);
                    const opacity = (0.1 + (mids * 0.5)) / (i + 1);
                    
                    ctx.beginPath();
                    for (let a = 0; a < Math.PI * 2; a += 0.1) {
                        // Distort the ring based on frequency data
                        const offsetIdx = Math.floor((a / (Math.PI * 2)) * data.length);
                        const distortion = (data[offsetIdx] / 255) * 40 * mids;
                        const r = radius + distortion;
                        const x = cx + Math.cos(a + (frame * 0.01 * (i + 1))) * r;
                        const y = cy + Math.sin(a + (frame * 0.01 * (i + 1))) * r;
                        
                        if (a === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.strokeStyle = i % 2 === 0 ? colors.blue : colors.orange;
                    ctx.lineWidth = 2 + (bass * 5);
                    ctx.globalAlpha = opacity;
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }

                // 6. THE CENTRAL "CORE"
                const coreSize = 40 + (totalEnergy * 60);
                ctx.shadowBlur = 20 + (bass * 40);
                ctx.shadowColor = colors.blue;
                
                // Core Glow
                const coreGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreSize);
                coreGrad.addColorStop(0, colors.white);
                coreGrad.addColorStop(0.3, colors.blue);
                coreGrad.addColorStop(1, 'transparent');
                
                ctx.fillStyle = coreGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, coreSize, 0, Math.PI * 2);
                ctx.fill();

                // 7. ELECTRIC DISCHARGE (HIGHS)
                if (highs > 0.5) {
                    ctx.beginPath();
                    ctx.strokeStyle = colors.white;
                    ctx.lineWidth = 1;
                    for (let j = 0; j < 5; j++) {
                        let tx = cx, ty = cy;
                        const angle = Math.random() * Math.PI * 2;
                        const length = 100 + (highs * 200);
                        
                        ctx.moveTo(tx, ty);
                        for (let seg = 0; seg < 5; seg++) {
                            tx += Math.cos(angle) * (length / 5) + (Math.random() - 0.5) * 50;
                            ty += Math.sin(angle) * (length / 5) + (Math.random() - 0.5) * 50;
                            ctx.lineTo(tx, ty);
                        }
                    }
                    ctx.stroke();
                }

                // 8. PARTICLE SWEAT (EMISSION)
                const particleCount = Math.floor(totalEnergy * 20);
                ctx.fillStyle = colors.purple;
                for (let p = 0; p < particleCount; p++) {
                    const pAngle = Math.random() * Math.PI * 2;
                    const pDist = coreSize + (Math.random() * 100 * mids);
                    const px = cx + Math.cos(pAngle + (frame * 0.05)) * pDist;
                    const py = cy + Math.sin(pAngle + (frame * 0.05)) * pDist;
                    ctx.beginPath();
                    ctx.arc(px, py, 1 + (highs * 3), 0, Math.PI * 2);
                    ctx.fill();
                }

                // Cleanup for next frame
                ctx.shadowBlur = 0;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }
        };
    </script>
</body>
</html>